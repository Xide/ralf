var searchIndex = {};
searchIndex["ralf"] = {"doc":"`Ralf` Distributed state machine with raft","items":[[3,"State","ralf","`State` is a wrapper around your state, allowing querying and modification",null,null],[3,"Action","","`Action` data type, contain a string identifier and raw bytes",null,null],[12,"cat","","Category of the action, simmilar to Redux action type (reserved keywork in Rust)",0,null],[12,"data","","Raw data associated with the action, parsing is left to the reducer Might change in the future",0,null],[3,"PureReducer","","Wrapper to use a pure function as a reducer",null,null],[3,"LoggingReducer","","`LoggingReducer` Print the category of each action received by the reducer `id` Leave the state unchanged",null,null],[3,"StateMachine","","State machine with a state of type `T`",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new state from an initial value",1,{"inputs":[{"name":"t"}],"output":{"name":"state"}}],[11,"get_state","","return a clone of the underlying data",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"set_state","","Edit the underlying data immmutably",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"new","","Create an action from it's category and raw data",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new pure reducer from it's id and function",2,null],[11,"id","","Getter to the structure id",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"process","","Call the reducer function",2,{"inputs":[{"name":"self"},{"name":"t"},{"name":"action"}],"output":{"name":"t"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"id","","Getter to the structure id",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"process","","Print the action and give back state ownership",3,{"inputs":[{"name":"self"},{"name":"t"},{"name":"action"}],"output":{"name":"t"}}],[11,"new","","Create a new logging reducer watching for reducer `id`",3,{"inputs":[{"name":"str"}],"output":{"name":"loggingreducer"}}],[11,"new","","Create a new state machine from an initial state Note: The returned machine will be empty, so actions won't have any effects until reducers are added.",4,{"inputs":[{"name":"t"}],"output":{"name":"statemachine"}}],[11,"push_reducer","","Add a reducer to the state machine",4,{"inputs":[{"name":"self"},{"generics":["reducer"],"name":"box"}],"output":{"name":"self"}}],[11,"process","","Action processing logic, generate the new state from (prev_state, action) and set the internal state to the new state.",4,{"inputs":[{"name":"self"},{"name":"action"}],"output":{"name":"self"}}],[11,"get_state","","Recover a copy of the state # Warning This method will clone the entire state, and is therefore potentially expensive",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"Reducer","","core logic trait, any structure that implement this trait can be used to manipulate state.",null,null],[10,"process","","Take the ownership of the state, and return the state after application of the action",5,{"inputs":[{"name":"self"},{"name":"t"},{"name":"action"}],"output":{"name":"t"}}],[10,"id","","id of the reducer. Reducers with the same id will share their state",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}]],"paths":[[3,"Action"],[3,"State"],[3,"PureReducer"],[3,"LoggingReducer"],[3,"StateMachine"],[8,"Reducer"]]};
initSearch(searchIndex);
